
1.Spring Bean的生命周期
初始化
依赖注入
接口BeanNameAware#setBeanName()
接口BeanFactoryAware#setBeanFactory()
接口ApplicationContextAware#setApplicationContext()(需要容器实现ApplicationContext接口才会被调用)
接口BeanPostProcessor#postProcessBeforeInitialization()(针对全部Bean生效)
注解@PostConstruct标注方法(自定义初始化方法)
接口InitializingBean#afterPropertiesSet()
接口BeanPostProcessor#postProcessAfterInitialization()(针对全部Bean生效)
生存期
注解@PreDestroy标注方法(自定义销毁方法)
接口DisposableBean#destory()

其中：
1.1 只有BeanPostProcessor是针对所有Bean而言的，而其他节点都是针对单个Bean而言的；
1.2 只有容器实现了ApplicationContext接口才会调用ApplicationContext的setApplicationContext()方法，
而Spring IoC容器最低要求是实现BeanFactory接口；
1.3 如果Bean定义使用的是第三方的类，可以使用注解@Bean来配置自定义初始化和销毁方法，如：
@Bean(initMethod = "init", destroyMethod = "destroy")

2.使用属性文件
@Value("${database.url}")
2.1 属性上使用@Value注解，不会调用setter方法，即对应的setter方法不会被调用
2.2 在setter方法上使用@Value注解，会调用setter方法
@ConfigurationProperties("database")
2.3 此种方式会调用属性对应的setter方法
@PropertySource(value = {"classpath:jdbc.properties"}, ignoreResourceNotFound = true)
2.4 指定属性文件

3.条件装配Bean
@Conditional(DatabaseConditional.class)
DatabaseConditional实现Condition接口，实现matches方法；

4.Bean的作用域
4.1 在Web容器中，存在页面/page、请求/request、会话/session、应用/application4中作用域；
对于页面/page，是针对JSP当前页面的作用域，所以Spring是无法支持的；
4.2 Spring作用域类型
4.2.1 singleton         所有Spring应用      默认值，IoC容器只存在单例
4.2.2 prototype         所有Spring应用      每当从IoC容器中取出一个Bean，则创建一个新的Bean
4.2.3 session           Spring Web应用      HTTP会话
4.2.4 application       Spring Web应用      Web工程生命周期，可以使用singleton来替代
4.2.5 request           Spring Web应用      Web工程单次请求（request）
4.2.5 globalSession     Spring Web应用      在一个全局的HTTP Session中，一个Bean定义对应一个实例。实践中基本不使用

ConfigurableBeanFactory只提供单例/SCOPE_SINGLETON和原型/SCOPE_PROTOTYPE两种作用域；
SpringMVC环境中，使用WebApplicationContext提供请求/SCOPE_REQUEST、会话/SCOPE_SESSION和应用SCOPE_APPLICATION；


